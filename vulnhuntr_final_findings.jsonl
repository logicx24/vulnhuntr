{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "RCE", "analysis": "{\n  \"analysis\": \"Remote input flows from WebSocket messages into protobuf messages and then into the Route RPC path; two high-risk concerns emerge: (1) RCE risk if the downstream Route/DeviceRelay interprets and executes user-supplied command_call data (payloads[].command_call.command and .arguments) on the server or a connected device; an attacker could craft a command to run arbitrary code when Route processes the payload. (2) IDOR risk via _get_session_device_id: if GetSession does not strictly enforce per-user authorization, a valid JWT could be used to retrieve device_id for another user/session, enabling unauthorized routing behavior or information exposure. The code also forwards JWTs via gRPC metadata, so misconfigurations or insufficient authorization checks downstream could compound risks. Mitigations include enforcing per-user authorization in GetSession, strict validation or allowlisting of allowed Route commands, server-side validation of Payload types and their semantics, minimizing or sandboxing command execution, and ensuring Route does not execute raw user input. To validate remotely, test with a payload containing a command_call that would execute on the server (e.g., a remote id or shell command) and observe whether any output is returned; test IDOR by attempting to fetch session/device mappings for sessions not owned by the JWT user. PoCs provided in the poc field illustrate the remote trigger vector and how to observe results.\"\n  ,\n  \"poc\": \"PoC 1 (RCE via Route): Send a WebSocket message containing a payload with a command_call designed to execute a system command on the server (assuming Route RPC interprets and executes it). Example JSON fragment to send as the WebSocket payloads: {\\\"session_id\\\":\\\"sess-remote\\\",\\\"payloads\\\":[{\\\"command_call\\\":{\\\"call_id\\\":\\\"cc-01\\\",\\\"command\\\":\\\"/bin/sh -c 'id'\\\",\\\"arguments\\\":{}}}]} If the backend executes this, the server may return the command output in subsequent chat messages or logs. PoC 2 (IDOR via GetSession): Use a valid JWT but request a session_id that belongs to another user; observe whether the GetSession RPC returns a device_id or related info for that session, indicating improper per-user access control. Note: PoC steps assume Route/GetSession behavior that processes command_call and returns/logs outputs; adapt to actual backend behavior observed during testing.\"\n  ,\n  \"confidence_score\": 6,\n  \"", "poc": "", "confidence_score": 0, "vulnerability_types": [], "context_code": []}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "XSS", "analysis": "XSS risk exists because the WebSocket handler accepts user-controlled payloads under payloads[].text.content, constructs a protobuf MessagePacket, forwards it to the Route RPC, and then echoes the response back to the client as JSON via _proto_to_json. If the frontend consumes this JSON and renders payloads[].text.content directly into the DOM without proper HTML escaping or sanitization, a remote attacker can inject script that executes in the victim's browser. The vulnerability is client-side (reflected/stored depending on how the UI stores/shows messages) and is contingent on downstream front-end rendering, not on server-side HTML generation. The server currently does not sanitize or encode text payloads when transforming them to JSON responses, nor does it perform any content-context-aware escaping. This makes an attacker-supplied payload like a script tag likely to be reflected back to the same or other clients. Potential bypass payloads in example bypass vectors (e.g., <script>alert(1)</script>, javascript: URLs) illustrate common DOM/HTML contexts that could be exploited if the client renders these strings unescaped. PoC involves sending a WebSocket message with payloads containing a crafted text payload and observing client-side execution if the front-end does not escape HTML before inserting into the DOM.", "poc": "WebSocket message payload to trigger XSS (example): {\"session_id\":\"sess_abc\",\"user_id\":1,\"workspace_id\":1,\"payloads\":[{\"text\":{\"content\":\"<script>alert('XSS')</script>\"}}]} Send this to the server via the established WebSocket connection. If the web UI renders payloads[].text.content as HTML without proper escaping, the script will execute in the victim's browser upon receipt of the response from Route RPC.", "confidence_score": 7, "vulnerability_types": ["XSS"], "context_code": []}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "IDOR", "analysis": "Summary: The WebSocket service proxies chat messages by resolving a device_id from a client-supplied session_id via a downstream GetSession RPC using the client\u2019s JWT, then forwards a RouterMessage to the Route RPC. There is no explicit authorization check after obtaining device_id to verify that the requested session_id actually belongs to the authenticated user/workspace. If downstream authorization (GetSession or Route) does not enforce per-user/session ownership, an attacker with a valid JWT could substitute another user\u2019s session_id to probe or interact with that user\u2019s session/device via the Route proxy (an IDOR path). Attack flow: 1) Attacker authenticates with a valid JWT for user A and opens a WebSocket connection. 2) Attacker sends a JSON chat message containing session_id of user B along with payloads. 3) The code calls _get_session_device_id(session_id, jwt_token, user_id, workspace_id) which uses GetSession with the attacker\u2019s JWT to retrieve a device_id; if GetSession lacks per-session scoping, the response maps to B\u2019s device. 4) The service constructs a RouterMessage with source_device_id set to B\u2019s device (if exposed) and routes it via Route RPC. 5) The response from Route is proxied back to the attacker, enabling cross-user interaction with B\u2019s session or device state. Potential leakage: session_id/device_id mappings could appear in logs by design; admin tokens (admin- prefix) may exacerbate impact if authorization checks are lax. Observed payloads include text, command_call, control_code, command_result, image; if the backend Route interprets these unsafely, there could be further risks (RCE via command_call or injection in downstream components). Mitigations: enforce strict per-session ownership in the WebSocket layer or strengthen authorization in downstream services; verify that GetSession enforces that session_id belongs to the JWT\u2019s user/workspace before exposing device_id; after device resolution, perform an explicit authorization check that the resolved device_id actually belongs to the authenticated user/workspace; avoid logging sensitive identifiers such as session_id or device_id; consider returning 403 or a generic error when ownership mismatch is detected; audit downstream RPCs (GetSession, Route) for per-user scoping and add explicit ownership checks at the boundary. PoC: with a valid JWT for user A, establish a WS connection and submit a message containing session_id of user B; if GetSession/Route do not enforce per-user ownership, the server will route the message associated with B\u2019s device and may reveal or effect state tied to B\u2019s session, demonstrating remote IDOR. This IDOR ability hinges on downstream authorization and not on the WebSocket code alone, so remediation should target GetSession and Route access controls and possibly bind session_id ownership to the authenticated identity at the WebSocket boundary.", "poc": "PoC outline: 1) Obtain a valid JWT for user A. 2) Open a WebSocket connection with Authorization: Bearer <token_A>. 3) Send a JSON chat message with session_id set to a target session_id belonging to user B and appropriate payloads (e.g., text). 4) If GetSession/GetSession-Route flows do not enforce per-user scoping, the backend may resolve device_id for B\u2019s session and proxy the message to Route, potentially exposing or manipulating B\u2019s device/chat state. Expected result: either the message is processed as if it belonged to B\u2019s session (IDOR success) or you observe messages that imply cross-user routing. Mitigations exercised should fail such behavior.", "confidence_score": 6, "vulnerability_types": ["IDOR"], "context_code": [{"name": "_get_session_device_id", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Clarify data flow for session to device mapping", "code_line": "def _get_session_device_id("}, {"name": "_handle_message", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Examine how remote messages are processed and proxied to Route", "code_line": "def _handle_message("}, {"name": "_extract_user_context_from_jwt", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Trace JWT parsing and user/workspace extraction", "code_line": "def _extract_user_context_from_jwt("}, {"name": "serve", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Starting WebSocket server orchestration", "code_line": "def serve(self) -> None:"}]}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "RCE", "analysis": "Remote-entry points identified: a public WebSocket interface accepts JSON messages, converts them into protobuf MessagePacket, and streams RouterMessage to the Route RPC service via DeviceRelay.Route; The primary RCE risk emerges if the Route backend executes user-controlled commands embedded in payloads such as command_call or control_code because the code forwards unvalidated input straight to the Route sink without server-side sanitization; Potential PoC: establish a WebSocket connection with an Authorization header containing a valid JWT, then send a message including a payload with command_call where command is an interactive shell invocation (e.g., bash) and arguments include a shell command (e.g., -lc id); if the Route backend dutifully executes the command on a device or on the server, the output could be returned via subsequent RouterMessage payloads, demonstrating remote code execution; Additional remote risks include possible IDOR if session/device resolution relies solely on session_id and JWT claims without proper ownership checks, XSS if user-provided payloads are echoed into WebSocket responses without escaping in a browser UI, DoS via long-lived or unbounded gRPC/WebSocket streams, and transport-level exposure since gRPC uses insecure_channel and the WebSocket server binds to 0.0.0.0; Mitigations include validating/whitelisting commands on the backend Route, enforcing strict authorization and session ownership checks before routing, limiting payload size and streaming duration, encoding outputs for clients, and enabling TLS/HTTPS/WSS for gRPC and WebSocket, plus reducing token exposure by not echoing sensitive headers in logs.", "poc": "PoC: 1) Connect to ws://<host>:<wss_port> with HTTP Authorization: Bearer <jwt_token>. 2) Send: {\"session_id\":\"sess-123\",\"user_id\":1,\"workspace_id\":1,\"timestamp\":<ts>,\"source\":\"user\",\"payloads\":[{\"command_call\":{\"call_id\":\"poc1\",\"command\":\"bash\",\"arguments\":{\"-lc\":\"id\"}}}]}. 3) If the Route sink executes the command, observe a response containing the command output embedded in a chat payload returned over the WebSocket. This proves remote code execution via the Route RPC backend when it blindly executes user-controlled commands.", "confidence_score": 7, "vulnerability_types": ["RCE", "IDOR"], "context_code": [{"name": "WebSocketService", "symbol_kind": "class", "request_type": "REQUEST_DEFINITION", "reason": "Primary entry point that accepts remote input via WebSocket.", "code_line": "class WebSocketService:"}, {"name": "_handle_message", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Core path from input to gRPC Route sink.", "code_line": "async def _handle_message("}, {"name": "_json_to_proto", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Converts JSON payload to protobuf MessagePacket fed into Route.", "code_line": "def _json_to_proto(self, json_data: Dict[str, Any]) -> service_pb2.MessagePacket:"}, {"name": "_get_session_device_id", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Resolves device_id for a given session to route messages to the correct target.", "code_line": "def _get_session_device_id("}]}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "IDOR", "analysis": "IDOR risk exists where WebSocket input (session_id) is used to resolve a device_id via _get_session_device_id without explicit ownership checks against the JWT-derived user/workspace context. The flow accepts remote JSON over WebSocket, validates a JWT to attach authorization metadata to gRPC calls, and then calls GetSession(session_id) to obtain a device_id, which is later used to wrap the chat in a RouterMessage and forwarded to Route. However, _get_session_device_id does not verify that the requested session_id actually belongs to the JWT subject (user/workspace); the code only uses the JWT to authorize the downstream gRPC call, and the subsequent device_id routing depends on the backend Route service enforcing ownership. If the Route/GetSession backend allows cross-session access (i.e., returns a device_id for sessions not owned by the JWT subject or if session ownership checks are lax), an attacker with a valid token could manipulate session_id to access or influence another user\u2019s device, session data, or routing targets. This constitutes an IDOR surface at the WebSocket boundary between remote input (session_id) and high-risk sinks (GetSession, Route). To mitigate, enforce explicit authorization checks on session_id ownership against the JWT claims at this boundary (ensure session_id maps to user/workspace in claims or a trusted ACL before proceeding), and ensure the Route/GetSession services enforce strict per-user session ownership. Consider binding session_id to the authenticated user/workspace, rejecting mismatches, and auditing access patterns. Additional remote-security considerations include potential RCE via crafted payloads to Route and transport-level exposure due to plaintext WebSocket/grpc unless TLS termination is enforced.", "poc": "Proof-of-Concept (IDOR via session_id misuse): 1) Acquire a valid JWT for user A within workspace W. 2) Establish a WebSocket connection to the server (ws://host:port) and send a JSON message where session_id is set to a value belonging to user B in workspace W (e.g., {\"session_id\":\"sess-for-user-B\" ,\"payloads\":[{\"text\":{\"content\":\"ping\"}}],\"timestamp\":0}). 3) Observe whether responses or forwarded messages originate from or pertain to user B\u2019s session/device, or whether the server returns device_id/metrics for B without enforcing ownership, indicating session-ownership bypass. If the Route backend returns data or routes messages to B\u2019s device despite the token belonging to A, IDOR is demonstrated. The test should be performed against a non-production test environment and with proper authorization to avoid harming real users.", "confidence_score": 6, "vulnerability_types": ["IDOR"], "context_code": [{"name": "WebSocketService", "symbol_kind": "class", "request_type": "REQUEST_DEFINITION", "reason": "Overall remote entrypoint and boundary for JWT validation and message handling", "code_line": "class WebSocketService:"}, {"name": "_get_session_device_id", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Session-device resolution flow to determine routing target; potential lack of ownership checks", "code_line": "response = service_stub.GetSession(request, metadata=metadata)"}, {"name": "_extract_user_context_from_jwt", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "JWT-to-user/workspace mapping; verify admin token behavior", "code_line": "claims = verify_jwt(jwt_token)"}, {"name": "verify_jwt", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "JWT verification and claims extraction to determine trust boundary", "code_line": "payload = jwt.decode(token, get_jwt_secret(), algorithms=[\"HS256\"])"}, {"name": "handle_connection", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "WebSocket connection entrypoint and token extraction from headers/query", "code_line": "async for message in websocket:"}]}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "XSS", "analysis": "The WebSocket service accepts remote JSON messages, converts them to protobuf MessagePacket via _json_to_proto without any sanitization, and then forwards the content back to the client via _proto_to_json after receiving RouterMessage payloads from the Route RPC; since the server does not escape or sanitize payload.text.content before embedding it in the JSON response that the frontend will render, a remote attacker can inject HTML/JS in payloads.text.content (e.g., <script> or event handlers) and if the client-side UI renders these values as HTML (using innerHTML or similar) instead of safe text, an XSS payload will execute in the victim\u2019s browser; this is exacerbated by the fact that the response can contain multiple messages in a streaming flow, potentially re-injecting unsanitized content into the DOM. The server currently relies on the frontend to perform proper escaping; therefore, XSS risk is primarily frontend-driven but originates from remote user input reaching the output context. Mitigations include enforcing output encoding/sanitization at render time on the client, applying server-side escaping or neutralization of payload.text.content before emitting JSON, and implementing a Content Security Policy (CSP) to limit inline script execution and other risky behaviors. Additional hardening could include validating payloads, restricting allowed content types, and ensuring all frontend rendering paths use textContent or proper escaping rather than innerHTML when displaying payloads.", "poc": "1) Open a WebSocket connection to the service (ws://<host>:<port> or wss depending on deployment). 2) Send a remote JSON message that injects HTML/JS into a chat payload, for example: {\"session_id\":\"sess-123\",\"user_id\":1,\"workspace_id\":1,\"timestamp\":<ts>,\"source\":\"user\",\"payloads\":[{\"text\":{\"content\":\"<img src=\\\"x\\\" onerror=\\\"alert(1)\\\">\"}}]} 3) If the client\u2019s UI renders payloads.text.content as HTML (e.g., using innerHTML), the script will execute in the user\u2019s browser upon receipt of the message. 4) Observe the alert/side effects in the victim\u2019s browser.", "confidence_score": 7, "vulnerability_types": ["XSS"], "context_code": [{"name": "_handle_message", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Trace remote XSS input path from WebSocket to Route", "code_line": "def _handle_message("}, {"name": "_proto_to_json", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Trace how payloads are serialized back to JSON for client rendering", "code_line": "def _proto_to_json("}]}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "RCE", "analysis": "No direct remote code execution (RCE) is performed in the WebSocket service itself. The code deserializes JSON input to protobuf messages and forwards them to a downstream gRPC Route service; there is no use of eval/exec, os.system, subprocess, pickle, or __import__ at the WebSocket layer. RCE would therefore require a vulnerability in downstream components (the Route/DeviceRelay/or NeoService) that interprets the payloads with executable semantics (e.g., command_call being executed, dynamic imports, or unsafe deserialization). This module does forward user-controlled content (session_id, payloads like command_call, text, image) as protobuf fields and as gRPC metadata (authorization). It does not perform server-side code evaluation or deserialization of untrusted Python objects, but it does rely on downstream services to enforce proper authorization and input handling; potential risks include (a) downstream RCE if Route interprets command_call or other payloads insecurely, (b) improper authorization/IDOR risk if session/device lookup does not sufficiently isolate users/workspaces, and (c) data leakage or channel abuse if JWT validation or metadata forwarding is misconfigured. Hardening should focus on validating downstream semantics, applying strict payload schema validation, rate limiting, and ensuring Route service does not execute user-provided commands; no evidence of client-side template injection or SSRF in this module. Overall, RCE is not directly exploitable in this code path; any exploit would derive from downstream components misusing the transmitted payloads.", "poc": "", "confidence_score": 3, "vulnerability_types": [], "context_code": [{"name": "WebSocketService", "symbol_kind": "class", "request_type": "REQUEST_DEFINITION", "reason": "Understand data flow from WebSocket to Route RPC", "code_line": "class WebSocketService:"}, {"name": "_handle_message", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Trace remote input path from WebSocket message to Route RPC", "code_line": "def _handle_message("}, {"name": "_json_to_proto", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Inspect how JSON payloads map to protobuf MessagePacket fields", "code_line": "def _json_to_proto(self, json_data: Dict[str, Any]) -> service_pb2.MessagePacket:"}, {"name": "_extract_user_context_from_jwt", "symbol_kind": "function", "request_type": "REQUEST_DEFINITION", "reason": "Trace extraction of user/workspace context from JWT used for auth and routing", "code_line": "def _extract_user_context_from_jwt(self, jwt_token: str) -> Optional[tuple]:"}]}
{"file_path": "/Users/aakashjapi/projects/neo/service/api/server/websocket_service.py", "vuln_type": "IDOR", "analysis": "IDOR risk identified: WebSocket flow uses a client-supplied session_id to resolve a device via GetSession and then routes a RouterMessage through Route RPC using the attacker\u2019s JWT; if there is no explicit ownership/authorization check ensuring the session_id belongs to the authenticated user/workspace before exposing chat payloads or permitting commands, a remote attacker could read or act on another user\u2019s session by supplying a victim session_id, potentially leaking messages or manipulating that session; mitigation requires strict per-session ownership checks on GetSession/Route endpoints, explicit authorization via has_permission-like controls, and ensuring Route RPC enforces per-session scoping rather than relying solely on JWT presence; PoC depends on the downstream service accepting the crafted session_id and returning data tied to that session, which would demonstrate an IDOR in the current flow.", "poc": "PoC: authenticated attacker connects to the WebSocket with their valid JWT and sends a JSON message containing a crafted session_id belonging to a target user (e.g., victim_session_id) along with a chat payload. If the backend returns messages from or allows actions on the target session (or simply exposes the target\u2019s chat payloads) without validating that the session_id is owned by the authenticated user/workspace, this demonstrates an IDOR vulnerability. Example remote payload: {\"session_id\":\"<victim_session_id>\",\"payloads\":[{\"text\":{\"content\":\"Hello\"}}],\"user_id\":<attacker_id>,\"workspace_id\":<attacker_ws>,\"timestamp\":<now>}. Expectation: response reveals or permits interaction with the victim\u2019s session content; remediation would require session ownership checks prior to GetSession/Route processing and stricter authorization on Route RPC.\n", "confidence_score": 7, "vulnerability_types": ["IDOR"], "context_code": [{"name": "handle_connection", "symbol_kind": "method", "request_type": "REQUEST_DEFINITION", "reason": "Trace remote input flow from WebSocket to _handle_message to gRPC routes; IDOR potential.", "code_line": "def handle_connection(self, websocket: ServerConnection) -> None:"}, {"name": "_get_session_device_id", "symbol_kind": "method", "request_type": "REQUEST_DEFINITION", "reason": "Check GetSession RPC usage for device ID resolution and authorization enforcement.", "code_line": "def _get_session_device_id("}]}
